{"id": "pangu-001", "meta_prompt": ["你是一个有用的编程助手"], "data": [{"role": "user", "content": "用 Python 写一个快速排序算法"}, {"role": "assistant", "content": "[unused16]快速排序是一种分治算法，需要选择pivot然后分区。[unused17]以下是Python实现的快速排序：\n\n```python\ndef quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)\n```"}]}
{"id": "pangu-002", "meta_prompt": ["你是一个有用的编程助手"], "data": [{"role": "user", "content": "解释 Rust 的生命周期 /no_think"}, {"role": "assistant", "content": "[unused16][unused17]Rust 的生命周期（lifetime）是编译器用来确保所有借用都有效的机制。生命周期注解告诉编译器引用的有效范围，防止悬垂引用。\n\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n这里 `'a` 表示返回值的生命周期与两个参数中较短的那个相同。"}]}
{"id": "pangu-003", "meta_prompt": ["你是一个智能助手，可以使用搜索工具"], "tools": "[{\"name\": \"search\", \"description\": \"搜索互联网信息\"}]", "data": [{"role": "user", "content": "搜索 Python 3.12 的新特性 /no_think"}, {"role": "assistant", "content": "[unused16][unused17][unused11]{\"name\":\"search\",\"query\":\"Python 3.12 new features\"}[unused12]Python 3.12 引入了多项改进：\n1. 更好的错误消息\n2. 类型参数语法 (PEP 695)\n3. f-string 改进\n4. 性能提升约 5%"}]}
{"id": "pangu-004", "meta_prompt": ["你是一个有用的编程助手"], "data": [{"role": "user", "content": "什么是 Docker？ /no_think[unused10][unused9]助手：[unused16][unused17]Docker 是一个容器化平台，可以将应用及其依赖打包到容器中运行。[unused10][unused9]用户：Docker 和虚拟机有什么区别？"}, {"role": "assistant", "content": "[unused16]Docker容器和虚拟机都是隔离技术，但实现方式不同。容器共享宿主机内核，更轻量。[unused17]Docker 容器与虚拟机的主要区别：\n\n| 特性 | Docker | 虚拟机 |\n|------|--------|--------|\n| 启动速度 | 秒级 | 分钟级 |\n| 资源占用 | 低 | 高 |\n| 隔离级别 | 进程级 | 系统级 |\n| 内核 | 共享宿主 | 独立 |"}]}
{"id": "pangu-005", "meta_prompt": ["你是数据分析师"], "tools": "[{\"name\": \"database_query\", \"description\": \"数据库查询\"}]", "data": [{"role": "user", "content": "查询上个月销售额"}, {"role": "assistant", "content": "[unused16]需要查询数据库获取销售数据。[unused17][unused11]{\"name\":\"database_query\",\"sql\":\"SELECT SUM(amount) FROM sales WHERE month='last_month'\"}[unused12]上月销售额为 1,234,567 元。"}, {"role": "user", "content": "按产品类别分析 /no_think"}, {"role": "assistant", "content": "[unused16][unused17][unused11]{\"name\":\"database_query\",\"sql\":\"SELECT category, SUM(amount) FROM sales GROUP BY category\"}[unused12]电子产品：500,000元；服装：300,000元；家居：200,000元。"}]}
{"id": "pangu-006", "meta_prompt": ["你是一个有用的编程助手"], "data": [{"role": "user", "content": "我的 Python 代码报错了：\n```python\ndef fibonacci(n):\n    if n <= 0:\n        return []\n    fib = [0, 1]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib\n\nprint(fibonacci(1))\n```\n输出是 [0, 1] 但我期望 n=1 时只返回 [0]"}, {"role": "assistant", "content": "[unused16]问题在于 n=1 时直接返回了 [0, 1]，没有处理 n=1 的边界情况。[unused17]问题出在初始化 `fib = [0, 1]` 后没有检查 n 的值。当 n=1 时应该只返回 [0]。修复如下：\n\n```python\ndef fibonacci(n):\n    if n <= 0:\n        return []\n    if n == 1:\n        return [0]\n    fib = [0, 1]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib\n```"}, {"role": "user", "content": "谢谢！那如果我想用递归实现呢？"}, {"role": "assistant", "content": "[unused16]递归实现斐波那契有两种方式：朴素递归和带记忆化的递归。朴素递归时间复杂度是 O(2^n)，不推荐。[unused17]递归实现可以用记忆化来优化：\n\n```python\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\ndef fibonacci(n):\n    return [fib(i) for i in range(n)]\n```\n\n`@lru_cache` 避免了重复计算，时间复杂度降为 O(n)。"}, {"role": "user", "content": "性能差多少？能帮我测一下吗？"}, {"role": "assistant", "content": "[unused16]需要用 timeit 来对比两种实现的性能。[unused17]用 `timeit` 对比一下：\n\n```python\nimport timeit\n\n# 迭代版本\ndef fib_iter(n):\n    if n <= 0: return []\n    if n == 1: return [0]\n    fib = [0, 1]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib\n\n# 递归+缓存版本\nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef _fib(n):\n    if n < 2: return n\n    return _fib(n-1) + _fib(n-2)\ndef fib_rec(n):\n    return [_fib(i) for i in range(n)]\n\nn = 100\nprint(f'迭代: {timeit.timeit(lambda: fib_iter(n), number=10000):.4f}s')\nprint(f'递归: {timeit.timeit(lambda: fib_rec(n), number=10000):.4f}s')\n```\n\n对于 n=100，迭代版本通常快 2-3 倍，因为递归有函数调用开销。但缓存后差距不大，都是 O(n)。"}]}
{"id": "pangu-007", "data": [{"role": "user", "content": "JavaScript 的 Promise 和 async/await 有什么区别？"}, {"role": "assistant", "content": "Promise 和 async/await 本质上是同一件事，async/await 是 Promise 的语法糖。\n\nPromise 写法：\n```javascript\nfetch('/api/data')\n  .then(res => res.json())\n  .then(data => console.log(data))\n  .catch(err => console.error(err));\n```\n\nasync/await 写法：\n```javascript\ntry {\n  const res = await fetch('/api/data');\n  const data = await res.json();\n  console.log(data);\n} catch (err) {\n  console.error(err);\n}\n```\n\nasync/await 更易读，尤其是多个异步操作串联时。"}]}
{"id": "pangu-008", "meta_prompt": ["你是一个有用的编程助手"], "data": [{"role": "user", "content": "帮我写一个 Go 的 HTTP server，支持 graceful shutdown"}, {"role": "assistant", "content": "[unused16]graceful shutdown 需要监听系统信号，然后调用 server.Shutdown()。[unused17]```go\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n)\n\nfunc main() {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Hello, World!\"))\n\t})\n\n\tsrv := &http.Server{Addr: \":8080\", Handler: mux}\n\n\tgo func() {\n\t\tlog.Println(\"Server starting on :8080\")\n\t\tif err := srv.ListenAndServe(); err != http.ErrServerClosed {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}()\n\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\t<-quit\n\n\tctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n\tdefer cancel()\n\tlog.Println(\"Shutting down...\")\n\tsrv.Shutdown(ctx)\n}\n```"}, {"role": "user", "content": "能加个 middleware 记录请求日志吗？"}, {"role": "assistant", "content": "[unused16]Go 的 middleware 模式是用函数包装 handler。[unused17]加一个日志 middleware：\n\n```go\nfunc loggingMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tstart := time.Now()\n\t\tlog.Printf(\"%s %s\", r.Method, r.URL.Path)\n\t\tnext.ServeHTTP(w, r)\n\t\tlog.Printf(\"Completed in %v\", time.Since(start))\n\t})\n}\n```\n\n然后在 main 里包装：\n```go\nsrv := &http.Server{Addr: \":8080\", Handler: loggingMiddleware(mux)}\n```"}]}
{"id": "pangu-009", "meta_prompt": ["你是一个有用的编程助手"], "data": [{"role": "user", "content": "帮我 review 这段代码：\n```python\nimport requests\n\ndef get_user_data(user_ids):\n    results = []\n    for uid in user_ids:\n        resp = requests.get(f'https://api.example.com/users/{uid}')\n        if resp.status_code == 200:\n            results.append(resp.json())\n    return results\n```"}, {"role": "assistant", "content": "[unused16]这段代码有几个问题：串行请求、没有错误处理、没有超时、没有重试。[unused17]几个改进建议：\n\n1. **串行请求太慢** — 用 `concurrent.futures` 或 `asyncio` 并发\n2. **没有超时** — `requests.get()` 可能永远挂起\n3. **没有错误处理** — 网络异常会直接崩溃\n4. **没有重试** — 临时故障会丢数据\n\n改进版：\n```python\nimport requests\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\ndef get_user_data(user_ids, max_workers=10, timeout=5):\n    def fetch_one(uid):\n        try:\n            resp = requests.get(\n                f'https://api.example.com/users/{uid}',\n                timeout=timeout\n            )\n            resp.raise_for_status()\n            return resp.json()\n        except requests.RequestException:\n            return None\n\n    results = []\n    with ThreadPoolExecutor(max_workers=max_workers) as pool:\n        futures = {pool.submit(fetch_one, uid): uid for uid in user_ids}\n        for future in as_completed(futures):\n            data = future.result()\n            if data:\n                results.append(data)\n    return results\n```"}]}
{"id": "pangu-010", "meta_prompt": ["你是一个有用的编程助手"], "tools": "[{\"name\": \"run_code\", \"description\": \"执行代码并返回结果\"}, {\"name\": \"read_file\", \"description\": \"读取文件内容\"}]", "data": [{"role": "user", "content": "帮我调试这个 TypeScript 项目，编译报错了 /no_think[unused10][unused9]助手：[unused16][unused17]好的，让我先看看项目结构和错误信息。[unused11]{\"name\":\"run_code\",\"code\":\"tsc --noEmit 2>&1\"}[unused12]src/index.ts(15,3): error TS2322: Type 'string' is not assignable to type 'number'.\nsrc/utils.ts(8,1): error TS7006: Parameter 'x' implicitly has an 'any' type.[unused10][unused9]用户：看到了，两个错误 /no_think"}, {"role": "assistant", "content": "[unused16][unused17]两个问题：\n\n1. **src/index.ts:15** — 类型不匹配，把 string 赋给了 number 类型的变量\n2. **src/utils.ts:8** — 缺少类型注解，开启了 strict 模式\n\n修复方案：\n```typescript\n// src/index.ts:15 — 检查变量类型，可能需要 parseInt() 或改类型声明\nconst count: number = parseInt(input, 10); // 如果 input 是 string\n\n// src/utils.ts:8 — 添加参数类型\nfunction transform(x: unknown): string { // 根据实际用途选择类型\n  return String(x);\n}\n```\n\n建议在 tsconfig.json 中确认 `strict: true` 是否是你想要的。"}]}
{"id": "pangu-011", "meta_prompt": ["你是一个有用的编程助手"], "data": [{"role": "user", "content": "用 Rust 实现一个简单的 LRU Cache"}, {"role": "assistant", "content": "[unused16]LRU Cache 需要 O(1) 的 get 和 put，经典实现是 HashMap + 双向链表。Rust 里可以用 LinkedHashMap 或手动实现。[unused17]用标准库实现一个简单的 LRU Cache：\n\n```rust\nuse std::collections::HashMap;\n\nstruct LRUCache {\n    capacity: usize,\n    map: HashMap<i32, i32>,\n    order: Vec<i32>,  // 简化版，用 Vec 模拟访问顺序\n}\n\nimpl LRUCache {\n    fn new(capacity: usize) -> Self {\n        LRUCache {\n            capacity,\n            map: HashMap::new(),\n            order: Vec::new(),\n        }\n    }\n\n    fn get(&mut self, key: i32) -> Option<i32> {\n        if let Some(&val) = self.map.get(&key) {\n            self.order.retain(|&k| k != key);\n            self.order.push(key);\n            Some(val)\n        } else {\n            None\n        }\n    }\n\n    fn put(&mut self, key: i32, value: i32) {\n        if self.map.contains_key(&key) {\n            self.order.retain(|&k| k != key);\n        } else if self.map.len() >= self.capacity {\n            let lru = self.order.remove(0);\n            self.map.remove(&lru);\n        }\n        self.map.insert(key, value);\n        self.order.push(key);\n    }\n}\n```\n\n注意：这个简化版 `get` 是 O(n)。生产环境应该用双向链表实现 O(1)。"}, {"role": "user", "content": "能改成泛型的吗？支持任意 key-value 类型"}, {"role": "assistant", "content": "[unused16]需要给 key 加 Hash + Eq 约束，value 加 Clone。[unused17]泛型版本：\n\n```rust\nuse std::collections::HashMap;\nuse std::hash::Hash;\n\nstruct LRUCache<K, V> {\n    capacity: usize,\n    map: HashMap<K, V>,\n    order: Vec<K>,\n}\n\nimpl<K: Hash + Eq + Clone, V> LRUCache<K, V> {\n    fn new(capacity: usize) -> Self {\n        LRUCache {\n            capacity,\n            map: HashMap::new(),\n            order: Vec::new(),\n        }\n    }\n\n    fn get(&mut self, key: &K) -> Option<&V> {\n        if self.map.contains_key(key) {\n            self.order.retain(|k| k != key);\n            self.order.push(key.clone());\n            self.map.get(key)\n        } else {\n            None\n        }\n    }\n\n    fn put(&mut self, key: K, value: V) {\n        if self.map.contains_key(&key) {\n            self.order.retain(|k| k != &key);\n        } else if self.map.len() >= self.capacity {\n            let lru = self.order.remove(0);\n            self.map.remove(&lru);\n        }\n        self.order.push(key.clone());\n        self.map.insert(key, value);\n    }\n}\n```\n\n现在可以 `LRUCache::<String, Vec<u8>>::new(100)` 这样用了。"}, {"role": "user", "content": "写几个测试用例"}, {"role": "assistant", "content": "[unused16]测试 LRU 的核心行为：基本存取、容量淘汰、访问后更新顺序。[unused17]```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_basic_get_put() {\n        let mut cache = LRUCache::<i32, String>::new(2);\n        cache.put(1, \"one\".to_string());\n        cache.put(2, \"two\".to_string());\n        assert_eq!(cache.get(&1), Some(&\"one\".to_string()));\n        assert_eq!(cache.get(&3), None);\n    }\n\n    #[test]\n    fn test_eviction() {\n        let mut cache = LRUCache::<i32, i32>::new(2);\n        cache.put(1, 1);\n        cache.put(2, 2);\n        cache.put(3, 3);  // evicts key 1\n        assert_eq!(cache.get(&1), None);\n        assert_eq!(cache.get(&2), Some(&2));\n        assert_eq!(cache.get(&3), Some(&3));\n    }\n\n    #[test]\n    fn test_access_updates_order() {\n        let mut cache = LRUCache::<i32, i32>::new(2);\n        cache.put(1, 1);\n        cache.put(2, 2);\n        cache.get(&1);     // access key 1, now key 2 is LRU\n        cache.put(3, 3);   // evicts key 2 (not 1)\n        assert_eq!(cache.get(&1), Some(&1));\n        assert_eq!(cache.get(&2), None);\n    }\n}\n```"}]}
{"id": "pangu-012", "meta_prompt": ["你是一个有用的编程助手"], "tools": "[{\"name\": \"search\", \"description\": \"搜索信息\"}, {\"name\": \"calculator\", \"description\": \"计算器\"}]", "data": [{"role": "user", "content": "帮我算一下，如果我有一个 100 万行的 CSV 文件，每行 500 字节，用 pandas 读取大概需要多少内存？ /no_think[unused10][unused9]助手：[unused16][unused17][unused11]{\"name\":\"calculator\",\"expression\":\"1000000 * 500 / 1024 / 1024\"}[unused12]大约 477 MB 的原始数据。但 pandas DataFrame 通常会占用原始数据 2-5 倍的内存，因为有索引、类型转换等开销。所以预计需要 1-2.5 GB 内存。[unused10][unused9]用户：那有什么办法优化内存占用吗？"}, {"role": "assistant", "content": "[unused16]pandas 内存优化有几个常用方法。[unused17]几个实用的优化方法：\n\n1. **指定 dtypes** — 避免默认 int64/float64\n```python\ndtypes = {'id': 'int32', 'name': 'category', 'amount': 'float32'}\ndf = pd.read_csv('data.csv', dtype=dtypes)\n```\n\n2. **分块读取** — 不一次性加载\n```python\nfor chunk in pd.read_csv('data.csv', chunksize=10000):\n    process(chunk)\n```\n\n3. **用 category 类型** — 重复值多的列\n4. **用 PyArrow backend** — `pd.read_csv('data.csv', engine='pyarrow')`\n5. **考虑 Polars** — 比 pandas 内存效率高 2-3 倍"}]}
